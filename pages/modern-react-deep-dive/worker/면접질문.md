### 1. setState가 비동기적으로 동작하는 이유를 설명 해주세요.
동적으로 변경되는 웹 사이트의 변경 사항마다 DOM을 업데이트하는 대신 렌더링 비용을 최소화 하기 위해 
rendering/reconciliation 단계에서 WIP 트리를 구축하고 변경 사항을 파악하는 작업은 비동기적이며 
commit 단계에서 동기적으로 일괄(batch) 업데이트 합니다

### 2. JSX에 대해 설명해 주세요.
JSX(JavaScript XML)라는 JavaScript에 XML, HTML을 추가하여 확장한 문법으로 자바스크립트의 정식문법은 아니며 babel같은 트랜스파일러에 의해 자바스크립트 코드로 변환되어 사용됩니다.

### 3. state와 props의 차이를 설명 해주세요.
props는 부모 컴포넌트로 부터 전달 받는 read-only 불변 데이터이고
state는 컴포넌트 내부의 변경 가능한 데이터라는 것이 차이점입니다

### 4. 컴포넌트에 대해 설명해 주세요.
컴포넌트는 html CSS 및 JS가 결합된 웹 앱의 독립적으로 재사용 가능한 UI 요소를 의미합니다

### 5. 함수형 컴포넌트와 클래스형 컴포넌트의 차이점을 설명해 주세요.
클래스형 컴포넌트와 함수형 컴포넌트의 차이점으로는
함수형 컴포넌트는 immutable한 props를 받기 때문에 랜더링 결과가 보장되고 클래스형 컴포넌트는 this를 통해 props를 참조하기 때문에 렌더링을 결과를 보장할 수 없는 차이점이 있습니다
또한 클래스형 컴포넌트에서는 리액트 라이프 사이클을 사용할 수 있고 함수형 컴포넌트에서는 hook을 사용할 수 있는 차이가 있습니다

### 6. 리액트의 렌더링 단계에 대해 설명해 주세요
리액트 렌더링은 렌더 단계와 커밋 단계로 나눌 수 있습니다
렌더 단계는 재조정으로 가상 DOM 요소의 변화를 감지하고 필요한 업데이트를 결정하는 단계입니다.
커밋 단계는 렌더 단계에서 결정된 변경 사항들을 실제 DOM에 반영하는 단계입니다.

### 리액트에서 배열을 렌더링할 때 forEach를 사용하지 않고 map을 사용하는 이유

### 원시타입과 참조타입에 대해 설명해 주세요

### 깊은 복사와 얕은 복사의 차이점을 설명해주세요	

### 초기 렌더링시 VDOM

### useEffect가 실행되는 3가지 방식

### useState가 한번만 업데이트 되는 이유

### custom hook이란 무엇인가요?

### hook을 사용하는 조건

### 기술 동향 파악은 어떻게 하고 계신가요

### CSS 선택자의 종류와 각각에 대해 설명해주세요

### CSS 선택자의 우선순위

### 전역 상태 관리 라이브러리 사용 경험에 대해 말해주세요

### tailwindcss 혹은 styled-component를 사용한 이유

### HOC란 무었인가요

### 리액트 최적화 방법

### useMemo랑 useCallback의 차이점

### react.memo와 useMemo의 차이

### SPA, MPA, SSR, CSR, SSG 차이점

### flux 패턴에 대해 설명 해주세요

### Context API란 무었인가요?
정의 :
- Context API는 React 컴포넌트 간에 값을 공유할 수 있게 해주는 기능입니다.
  전역적으로 공유할 값을 다룰 때 주로 사용되지만, 반드시 전역적일 필요는 없습니다.

- 사용 이유: props drilling을 해결할 때 사용합니다.

### 성능 최적화를 한 경험이 있으시다면 말씀해 주시고 없으시다면 알고 있는 최적화 방법을 말씀해주세요.

### 클로저란 무었이고 리액트에서 어떻게 사용할 수 있나요?

### CSS position 에 대해 설명해주세요
<details>
<summary>답변</summary>

CSS에서 position 속성은 요소의 위치 지정 방식을 결정하는 중요한 속성입니다. 총 5가지 값(static, relative, absolute, fixed, sticky)을 가질 수 있습니다.  

static (기본값) 정적 위치 지정으로, 기본 렌더링 흐름에 따라 배치됩니다. top, bottom, left, right 속성이 적용되지 않습니다. 

relative 상대 위치 지정으로, 정적 위치에서 top, bottom, left, right 속성에 따라 위치가 이동합니다. 레이아웃에는 영향을 미치지 않습니다. 

absolute 절대 위치 지정으로, 가장 가까운 조상(relative, absolute, fixed 중 하나) 요소를 기준으로 위치가 결정됩니다. 일반 렌더링 흐름에서 벗어납니다. 

fixed 고정 위치 지정으로, 뷰포트(viewport) 기준으로 위치가 결정됩니다. 스크롤에도 영향을 받지 않습니다. 

sticky 스크롤 영역 기반 위치 지정입니다. 평소에는 정상 위치에 있다가, 가로 또는 세로 스크롤 위치가 설정된 위치에 다다르면 고정됩니다.
</details>

### 호이스팅에 대해 설명해주세요
<details>
<summary>답변</summary>

호이스팅은 자바스크립트 실행 컨텍스트가 만들어질 때 발생하는 현상입니다. 실행 컨텍스트가 생성되면 코드가 실행되기에 앞서 변수 및 함수 선언에 대한 초기화 단계가 먼저 진행됩니다. 이 과정에서 모든 변수 선언문은 단일 스코프에서 해당 스코프의 상단으로 가상적으로 이동되는 것처럼 동작합니다. 이를 호이스팅이라고 부릅니다.

변수의 경우 선언문만 호이스팅되고 할당문은 호이스팅되지 않습니다. 따라서 변수를 선언하고 초기화하기 이전에 해당 변수에 접근하면 undefined를 반환합니다.

함수 선언문의 경우 완전한 함수 정의 전체가 호이스팅됩니다. 하지만 함수 표현식은 함수 이름만 호이스팅되고 할당문 자체는 호이스팅되지 않습니다.

함수 선언문은 호이스팅이 일어나지만, 함수 표현식은 호이스팅이 일어나지 않습니다. 
</details>

### 클로저에 대해 설명해주세요
<details>
<summary>답변</summary>

클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. 중첩 함수가 있을 때, 내부 함수가 외부 함수의 변수를 참조하는데 외부 함수의 실행이 종료된 이후에도 내부 함수가 외부 함수의 변수를 계속 참조할 수 있는 경우가 클로저입니다. 리액트에서 커스텀 훅을 만들거나 자바스크립트로 계산기, 투두리스트 등을 만들며 상태 관리를 할 때 클로저를 사용한 경험이 있습니다. 
</details>

### 브라우저 렌더링 과정에 대해 설명해주세요
<details>
<summary>답변</summary>

브라우저는 개코나 웹킷 엔진으로 구동됩니다. 일반적으로 HTML 파일을 파싱하여 DOM 트리를 생성하고, CSS 파일을 파싱하여 CSSOM 트리를 만듭니다. 이렇게 생성된 두 개의 트리를 합쳐 렌더 트리를 생성한 후, 레이아웃과 페인팅 과정을 거쳐 화면에 렌더링합니다. 
</details>

### 리플로우/리페인트에 대해 설명해주세요
<details>
<summary>답변</summary>

리플로우는 이 렌더 트리의 일부 또는 전체 구조를 재계산하고 재배치해야 할 때 일어납니다. 리페인트는 시각적인 요소의 변경이 있을 때 발생하며, 예를 들어 visibility 이나 background-color, opacity , 폰트변경 등이 변경되었을 때입니다. 리플로우가 일어나면 반드시 리페인트가 발생합니다.

리플로우의 비용이 리페인트보다 비쌉니다. 왜냐하면 리플로우는 렌더 트리의 일부 또는 전체 구조를 재계산해야 하기 때문입니다

display: none 속성을 사용하여 레이아웃 단계를 다시 실행하지 않는 방법으로 최적화할 수 있을 것 같습니다.
</details>


### 마진/패딩에 대해 설명해주세요
<details>
<summary>답변</summary>

CSS에서 margin은 박스 모델의 border 바깥쪽에 있는 여백을 말하고, padding은 border 안쪽에 있는 여백을 말합니다. margin은 요소와 요소 사이의 간격을 정의할 때 주로 사용하고, padding은 요소 내부 콘텐츠와 border 사이의 간격을 정의할 때 주로 사용합니다. 
</details>

### 리액트 라이프사이클에 대해 설명해주세요
<details>
<summary>답변</summary>

리액트 라이프사이클에는 마운트, 업데이트, 언마운트 과정이 있습니다. 이를 리액트 함수형 컴포넌트에서는 useEffect를 통해 비슷하게 구현할 수 있습니다. 처음 렌더링 될 때는 useEffect의 콜백 함수가 실행되어 마운트 과정을 구현합니다. 업데이트될 때는 useEffect의 의존성 배열 안의 의존 변수가 변경되면서 콜백 함수가 다시 실행되어 업데이트 과정을 구현합니다. 언마운트될 때는 useEffect 안의 클린업 함수가 반환되면서 실행되어 언마운트 과정을 구현합니다. 
</details>

### VDOM 에 대해 설명해주세요
<details>
<summary>답변</summary>

VDOM은 리액트에서 UI를 효율적으로 렌더링하기 위해 메모리 상에 가상의 DOM 트리 구조를 만들어 활용하는 개념입니다. 
VDOM은 링크드 리스트로 구현된 트리 구조이며, 각 노드는 파이버 구조로 이루어져 있습니다.
파이버 구조 안에는 각 컴포넌트의 상태, 프롭스, DOM 정보 등이 저장됩니다. 
더블 버퍼링 방식을 사용하여 현재 트리(커런트 트리)와 작업 중인 트리(워킹 인 프로그레스 트리)가 존재합니다.
초기 렌더링 시에는 전체 UI를 VDOM으로 메모리에 저장하고, 리렌더링이 발생하면 렌더 단계에서 현재 트리와 작업 중인 트리를 비교하여 변경된 부분을 탐지하는 재조정 과정을 비동기적으로 거친 후, 커밋 단계에서 변경된 부분만 실제 DOM에 동기적으로 반영합니다.
</details>